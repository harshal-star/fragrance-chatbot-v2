<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <title>Your Personal Fragrance Stylist</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: {
                light: '#F3E5F5',
                DEFAULT: '#9C27B0',
                dark: '#6A1B9A',
              },
              accent: {
                light: '#E1BEE7',
                DEFAULT: '#8E24AA',
              },
              background: {
                light: '#FFFFFF',
                dark: '#121212',
              },
              text: {
                primary: '#2C3E50',
                secondary: '#7F8C8D',
              },
              success: '#4CAF50',
              error: '#F44336',
            },
            fontFamily: {
              inter: ['Inter', 'sans-serif'],
            },
            borderRadius: {
              chat: '18px',
            },
            boxShadow: {
              chat: '0 4px 12px rgba(156, 39, 176, 0.2)',
              bot: '0 4px 12px rgba(0,0,0,0.1)',
            },
          },
        },
      }
    </script>
    <style>
      html { scroll-behavior: smooth; }
      .streaming-cursor { animation: blink 1s steps(2, start) infinite; }
      @keyframes blink { to { visibility: hidden; } }
      .dot { display: inline-block; width: 8px; height: 8px; margin-right: 4px; background-color: #9C27B0; border-radius: 50%; animation: wave 1.3s linear infinite; opacity: 0.6; }
      .dot:nth-child(2) { animation-delay: -1.1s; }
      .dot:nth-child(3) { animation-delay: -0.9s; }
      @keyframes wave { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-4px); } }
      .dynamic-loading .loading-fade { animation: fadeInOut 1.2s infinite; transition: opacity 0.3s; }
      @keyframes fadeInOut { 0% { opacity: 0.2; } 50% { opacity: 1; } 100% { opacity: 0.2; } }
    </style>
</head>
<body class="bg-gradient-to-br from-primary-light to-white min-h-screen font-inter text-text-primary flex flex-col">
    <div class="flex flex-col w-full h-screen">
        <!-- Header -->
        <header class="flex items-center justify-between bg-gradient-to-r from-accent to-primary-dark px-4 py-3 md:px-6 md:py-4 shadow-md">
            <div class="flex items-center gap-2">
                <button id="toggle-sidebar-btn" class="bg-primary-dark text-white rounded-full w-8 h-8 flex items-center justify-center hover:bg-primary focus:outline-none" title="Collapse sidebar">
                    <span id="toggle-sidebar-icon">&#x25C0;</span>
                </button>
            </div>
            <div class="flex flex-col items-center">
                <h1 class="text-lg md:text-xl font-bold text-white">Your Personal Fragrance Stylist</h1>
                <span class="text-accent-light text-xs md:text-sm">Discover Your Signature Scent</span>
            </div>
            <div class="header-new-chat-btn">
                <button class="bg-accent text-white px-3 py-1.5 md:px-4 md:py-2 rounded-lg font-medium shadow hover:bg-primary-dark transition new-chat-button" id="new-chat-btn">+ New Chat</button>
            </div>
        </header>
        <div class="flex flex-1 overflow-hidden">
            <!-- Sidebar -->
            <aside id="sidebar" class="sidebar w-64 bg-background-dark text-white flex flex-col border-r border-gray-700 transition-all duration-300 z-10">
                <div class="sidebar-header bg-primary-dark px-4 py-3 font-bold text-lg">Lila</div>
                <div id="session-list" class="flex-1 overflow-y-auto mt-2 px-2"></div>
            </aside>
            <!-- Main Panel -->
            <div class="main-panel flex flex-col flex-1 h-full bg-gradient-to-b from-background-light to-primary-light transition-all duration-300">
                <!-- Chat Messages -->
                <div id="chat-messages" class="flex-1 overflow-y-auto p-4 md:p-6 flex flex-col gap-4"></div>
                <!-- Image Preview (dynamic) -->
                <div id="image-preview-container" class="image-preview-container"></div>
                <!-- Chat Input -->
                <form id="chat-form" class="flex items-center gap-2 p-3 md:p-4 border-t bg-white">
                    <input id="user-input" type="text" placeholder="Type your message here..." autocomplete="off" class="flex-1 px-4 py-2 rounded-full border border-gray-300 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary text-base" />
                    <input type="file" id="image-upload" accept="image/*" multiple class="hidden" />
                    <button id="upload-button" type="button" class="bg-gradient-to-r from-primary-light to-primary px-3 py-2 rounded-full text-white flex items-center gap-2 hover:from-primary hover:to-accent transition" title="Upload image">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                    </button>
                    <button id="send-button" type="submit" class="bg-primary text-white px-6 py-2 rounded-full font-semibold shadow hover:bg-primary-dark transition flex items-center gap-2">
                        <span>Send</span>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                </form>
            </div>
        </div>
    </div>
    <!-- All your existing JavaScript logic remains below, unchanged -->
    <script>
        let sessionId = null;
        let userId = localStorage.getItem('userId') || 'user_' + Math.random().toString(36).substr(2, 9);
        let isTyping = false;
        let typingTimeout;
        let currentStreamingMessage = null;
        
        // Use environment-specific API URL
        const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:8000/api/v1'
            : 'https://fragrance-chatbot-v3.onrender.com/api/v1';
        
        const START_SESSION_URL = `${API_BASE_URL}/start-session`;
        const CHAT_URL = `${API_BASE_URL}/chat`;
        const START_SESSION_STREAM_URL = `${API_BASE_URL}/start-session-stream`;
        
        // Save user ID to localStorage
        localStorage.setItem('userId', userId);

        function formatMessage(message) {
            // Use marked to convert markdown to HTML
            return marked.parse(message);
        }

        function getTimestamp() {
            const now = new Date();
            return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        function createMessageElement(isUser) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';
            timestampDiv.textContent = getTimestamp();
            
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(timestampDiv);
            
            if (isUser) {
                const statusDiv = document.createElement('div');
                statusDiv.className = 'message-status';
                statusDiv.textContent = 'Sent';
                messageDiv.appendChild(statusDiv);
            }
            
            return { messageDiv, contentDiv };
        }
        
        function addMessage(message, isUser, showTimestamp = true) {
            const chatMessages = document.getElementById('chat-messages');
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `message flex flex-col max-w-[85%] ${isUser ? 'self-end items-end' : 'self-start items-start'} mb-2`;

            const messageContent = document.createElement('div');
            messageContent.className = `prose max-w-none message-content px-5 py-3 rounded-chat shadow-chat text-base ${isUser ? 'bg-gradient-to-br from-primary to-accent text-white rounded-br-md' : 'bg-white text-text-primary rounded-bl-md border border-gray-200'} mb-1`;
            messageContent.innerHTML = formatMessage(message);
            messageWrapper.appendChild(messageContent);

            // Only show timestamp if requested (not during streaming)
            if (showTimestamp) {
                const timestamp = document.createElement('div');
                timestamp.className = 'message-timestamp text-xs text-text-secondary mt-1';
                const now = new Date();
                timestamp.textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                messageWrapper.appendChild(timestamp);
            }
            chatMessages.appendChild(messageWrapper);
            chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
            return messageContent;
        }

        function startStreamingResponse(isUser = false) {
            // Only show the message bubble, no timestamp yet
            return addMessage('', isUser, false);
        }

        function updateStreamingResponse(formattedText) {
            if (currentStreamingMessage) {
                currentStreamingMessage.innerHTML = formattedText + '<span class="streaming-cursor">|</span>';
                const chatMessages = document.getElementById('chat-messages');
                chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
            }
        }

        function endStreamingResponse() {
            if (currentStreamingMessage) {
                // Remove the streaming cursor
                const cursor = currentStreamingMessage.querySelector('.streaming-cursor');
                if (cursor) cursor.remove();
                // Add timestamp after streaming is done
                const parent = currentStreamingMessage.parentElement;
                if (parent && !parent.querySelector('.message-timestamp')) {
                    const timestamp = document.createElement('div');
                    timestamp.className = 'message-timestamp text-xs text-text-secondary mt-1';
                    const now = new Date();
                    timestamp.textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    parent.appendChild(timestamp);
                }
                currentStreamingMessage = null;
            }
        }

        function showTypingIndicator() {
            /* No-op: handled by streaming response now */
        }

        function hideTypingIndicator() {
            /* No-op: handled by streaming response now */
        }

        let lastTypingUpdate = 0;
        const TYPING_THROTTLE = 2000; // 2 seconds

        function updateTypingPreview() {
            const now = Date.now();
            if (now - lastTypingUpdate > TYPING_THROTTLE) {
                const input = document.getElementById('user-input');
                const preview = document.getElementById('typing-preview');
                
                if (input.value.trim() && !isTyping) {
                    // Show "User is typing..." to the bot
                    lastTypingUpdate = now;
                }
            }
        }

        async function startSessionStream() {
            const response = await fetch(START_SESSION_STREAM_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: userId })
            });
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let botMessage = '';
            currentStreamingMessage = startStreamingResponse();
            let sessionIdSet = false;
            let leftover = '';
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const chunk = leftover + decoder.decode(value);
                const lines = chunk.split('\n');
                leftover = lines.pop(); // In case the last line is incomplete
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.startsWith('event: sessionId')) {
                        // Next line should be data: <session_id>
                        if (i + 1 < lines.length && lines[i + 1].startsWith('data: ')) {
                            sessionId = lines[i + 1].slice(6).trim();
                            sessionIdSet = true;
                            i++; // Skip the data line
                        }
                    } else if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        botMessage += data; // Accumulate streamed chunks
                        const safeHTML = DOMPurify.sanitize(marked.parse(botMessage));updateStreamingResponse(safeHTML);
                    }
                }
            }
            endStreamingResponse();
            // Finalize the streaming message with full formatting
            if (currentStreamingMessage) {
                currentStreamingMessage.innerHTML = formatMessage(botMessage);
                currentStreamingMessage = null;
            }
            await loadSessionList(); // Refresh the left panel after streaming welcome message
        }

        async function initializeChat() {
            try {
                // Check if this is the first time user is visiting
                const isFirstVisit = !localStorage.getItem('hasVisited');
                await startSessionStream();  // Stream the welcome message
                // Mark that user has visited
                localStorage.setItem('hasVisited', 'true');
            } catch (error) {
                console.error('Error initializing chat:', error);
                addMessage('Sorry, I encountered an error. Please try again.', false);
            }
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function throttle(fn, delay) {
            let lastCall = 0;
            return (...args) => {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    fn(...args);
                }
            };
        }

        async function sendMessage() {
            const input = document.getElementById('user-input');
            const message = input.value.trim();
            
            // Prevent sending if sessionId is null
            if (!sessionId) {
                addMessage('Sorry, there was an error starting the session. Please refresh the page.', false);
                return;
            }
            
            if (message) {
                const messageId = generateUUID();
                // Show the user message immediately (optimistic UI)
                addMessage(message, true);

                input.value = '';
                showTypingIndicator();
                
                try {
                    // Use streaming for chat responses
                    const response = await fetch(CHAT_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            session_id: sessionId,
                            message: message,
                            message_id: messageId
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let rawMarkdown = '';
                    let streamingStarted = false;
                    let streamingBubble = null;

                    const throttledRender = throttle(() => {
                        if (currentStreamingMessage) {
                            const html = DOMPurify.sanitize(marked.parse(rawMarkdown));
                            currentStreamingMessage.innerHTML = html + '<span class="streaming-cursor">|</span>';
                        }
                    }, 150);

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                rawMarkdown += data;

                                if (!streamingStarted) {
                                    streamingBubble = startStreamingResponse();
                                    currentStreamingMessage = streamingBubble;
                                    streamingStarted = true;
                                }

                                throttledRender();
                            }
                        }
                    }

                    // Final rendering after complete message is received
                    if (currentStreamingMessage) {
                        const finalHTML = DOMPurify.sanitize(marked.parse(rawMarkdown));
                        currentStreamingMessage.innerHTML = finalHTML;
                    }

                    endStreamingResponse();

                    // After the message is sent and processed, reload the chat history:
                    // await loadChatHistory(sessionId);
                    // Update status to "Seen" after a short delay
                    setTimeout(() => {
                        const statuses = document.getElementsByClassName('message-status');
                        if (statuses.length > 0) {
                            statuses[statuses.length - 1].textContent = 'Seen';
                        }
                    }, 1000);
                } catch (error) {
                    console.error('Error:', error);
                    hideTypingIndicator();
                    addMessage('Sorry, there was an error processing your message. Please try again.', false);
                }
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            } else {
                updateTypingPreview();
            }
        }

        // Start chat when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            document.getElementById('user-input').focus();
            // Hide collapse button immediately if sidebar is not collapsed
            const collapseBtn = document.getElementById('collapse-sidebar-btn');
            if (collapseBtn && !document.getElementById('sidebar').classList.contains('collapsed')) {
                collapseBtn.style.display = 'none';
            }
            await loadSessionList(); // Load session list first!
            // Only initialize chat if there is no session selected
            if (!sessionId) {
                await initializeChat();
            } else {
                await loadChatHistory(sessionId);
            }
            const chatForm = document.getElementById('chat-form');
            if (chatForm) {
                chatForm.addEventListener('submit', async (e) => {
                    e.preventDefault(); // Prevent page reload on form submit
                    await sendMessage();
                });
            }
        });

        // Add input event listener for typing preview
        document.getElementById('user-input').addEventListener('input', updateTypingPreview);

        async function startSession(isNewChat = false) {
            try {
                const response = await fetch(START_SESSION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        is_new_chat: isNewChat
                    })
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('Start session response:', data);
                sessionId = data.session_id;
                return data;
            } catch (error) {
                console.error('Error starting session:', error);
                return { message: 'Sorry, I encountered an error starting our conversation. Please try again.' };
            }
        }

        async function startNewConversation() {
            try {
                document.getElementById('chat-messages').innerHTML = '';
                sessionId = null;
                // Use the streaming endpoint and logic
                await startSessionStream();
                document.getElementById('user-input').focus();
                await loadSessionList();
            } catch (error) {
                console.error('Error starting new conversation:', error);
                addMessage('Sorry, there was an error starting a new conversation. Please try again.', false);
            }
        }

        async function handleImageUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            // Add user message about multiple images
            addMessage(`I've uploaded ${files.length} photo${files.length > 1 ? 's' : ''} of myself`, true);

            for (let i = 0; i < files.length; i++) {
                // Create a wrapper for preview + analysis
                const wrapper = document.createElement('div');
                wrapper.className = 'flex flex-col items-start mb-4';

                // Show preview
                const reader = new FileReader();
                const img = document.createElement('img');
                img.className = 'image-preview mb-2 rounded-lg shadow';
                img.alt = `Image ${i + 1}`;
                reader.onload = function(e) {
                    img.src = e.target.result;
                };
                reader.readAsDataURL(files[i]);
                wrapper.appendChild(img);

                // Show loading indicator
                const loadingBotMessage = document.createElement('div');
                loadingBotMessage.className = 'bot-message mt-2';
                loadingBotMessage.style.position = 'relative';
                loadingBotMessage.style.minHeight = '48px';
                loadingBotMessage.style.display = 'flex';
                loadingBotMessage.style.alignItems = 'center';
                loadingBotMessage.style.justifyContent = 'flex-start';
                loadingBotMessage.style.marginTop = '12px';
                loadingBotMessage.style.marginBottom = '12px';
                // Loading dots
                const loadingMessage = document.createElement('div');
                loadingMessage.className = 'dynamic-loading';
                const loadingTextSpan = document.createElement('span');
                loadingTextSpan.className = 'loading-fade';
                loadingTextSpan.style.marginLeft = '8px';
                loadingTextSpan.textContent = 'Analyzing your image...';
                loadingMessage.appendChild(loadingTextSpan);
                loadingBotMessage.appendChild(loadingMessage);
                wrapper.appendChild(loadingBotMessage);

                document.getElementById('chat-messages').appendChild(wrapper);

                // Convert image to base64
                const base64Image = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = error => reject(error);
                    reader.readAsDataURL(files[i]);
                });

                try {
                    // Send image to server and stream the response
                    const response = await fetch(CHAT_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            session_id: sessionId,
                            message: `Analyzing image ${i + 1} of ${files.length}`,
                            image_data: base64Image
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    // Streaming logic for image analysis
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let accumulatedMarkdown = '';
                    let streamingStarted = false;
                    let streamingBubble = null;
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                accumulatedMarkdown += data;
                                if (!streamingStarted) {
                                    streamingBubble = startStreamingResponse();
                                    currentStreamingMessage = streamingBubble;
                                    streamingStarted = true;
                                }
                                // Real-time markdown rendering using marked and DOMPurify
                                const html = DOMPurify.sanitize(marked.parse(`**Analysis for image ${i + 1}:**\n${accumulatedMarkdown}`));
                                currentStreamingMessage.innerHTML = html + '<span class="streaming-cursor">|</span>';
                            }
                        }
                    }
                    // After streaming, remove the cursor
                    if (currentStreamingMessage) {
                        const html = DOMPurify.sanitize(marked.parse(`**Analysis for image ${i + 1}:**\n${accumulatedMarkdown}`));
                        currentStreamingMessage.innerHTML = html;
                    }
                    endStreamingResponse();
                } catch (error) {
                    console.error('Error processing image:', error);
                    loadingBotMessage.replaceWith(document.createTextNode('Sorry, there was an error processing your image. Please try again.'));
                }
            }
        }

        function truncatePreview(text, maxLength = 40) {
            if (!text) return '';
            return text.length > maxLength ? text.slice(0, maxLength) + '...' : text;
        }

        async function loadSessionList() {
            const response = await fetch(`${API_BASE_URL}/sessions/${userId}`);
            const sessions = await response.json();
            const sessionListDiv = document.getElementById('session-list');
            sessionListDiv.innerHTML = '';
            sessions.forEach(session => {
                const isActive = session.session_id === sessionId;
                const div = document.createElement('div');
                div.className = 'session-item cursor-pointer flex flex-col px-4 py-3 mb-2 rounded-lg transition border border-transparent';
                if (isActive) {
                    div.classList.add('bg-primary', 'text-white', 'border-primary', 'shadow');
                    div.innerHTML = `
                        <div class="session-preview font-semibold text-base truncate text-white">${truncatePreview(session.preview, 40) || 'No messages yet...'}</div>
                        <div class="session-date text-xs text-accent-light mt-1">${new Date(session.updated_at).toLocaleString()}</div>
                    `;
                } else {
                    div.classList.add('bg-background-light', 'text-text-primary', 'hover:bg-primary-light', 'hover:border-primary/30');
                    div.innerHTML = `
                        <div class="session-preview font-semibold text-base truncate text-text-primary">${truncatePreview(session.preview, 40) || 'No messages yet...'}</div>
                        <div class="session-date text-xs text-text-secondary mt-1">${new Date(session.updated_at).toLocaleString()}</div>
                    `;
                }
                div.onclick = () => selectSession(session.session_id);
                sessionListDiv.appendChild(div);
            });
        }

        async function selectSession(sid) {
            sessionId = sid;
            await loadChatHistory(sid);
            await loadSessionList();
        }

        async function loadChatHistory(sid) {
            const response = await fetch(`${API_BASE_URL}/history/${sid}`);
            const data = await response.json();
            document.getElementById('chat-messages').innerHTML = '';
            console.log('Loaded chat history:', data.messages); // Debug: log all messages
            data.messages.forEach(msg => {
                addMessage(msg.content, msg.role === 'user');
            });
        }

        const sidebar = document.getElementById('sidebar');
        const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');
        const toggleSidebarIcon = document.getElementById('toggle-sidebar-icon');

        toggleSidebarBtn.addEventListener('click', function() {
            if (sidebar.classList.contains('collapsed')) {
                sidebar.classList.remove('collapsed');
                toggleSidebarIcon.innerHTML = '&#x25C0;'; // Left arrow
                toggleSidebarBtn.title = 'Collapse sidebar';
            } else {
                sidebar.classList.add('collapsed');
                toggleSidebarIcon.innerHTML = '&#x25B6;'; // Right arrow
                toggleSidebarBtn.title = 'Expand sidebar';
            }
        });
        if (sidebar.classList.contains('collapsed')) {
            toggleSidebarIcon.innerHTML = '&#x25B6;';
            toggleSidebarBtn.title = 'Expand sidebar';
        } else {
            toggleSidebarIcon.innerHTML = '&#x25C0;';
            toggleSidebarBtn.title = 'Collapse sidebar';
        }

        document.getElementById('new-chat-btn').addEventListener('click', startNewConversation);
        document.getElementById('upload-button').addEventListener('click', function() {
            document.getElementById('image-upload').click();
        });
        document.getElementById('image-upload').addEventListener('change', handleImageUpload);
    </script>
</body>
</html> 