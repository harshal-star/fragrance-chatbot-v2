<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <title>Lila - Your Personal Fragrance Stylist</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: {
                light: '#F3E5F5',
                DEFAULT: '#9C27B0',
                dark: '#6A1B9A',
              },
              accent: {
                light: '#E1BEE7',
                DEFAULT: '#8E24AA',
              },
              background: {
                light: '#FFFFFF',
                dark: '#121212',
              },
              text: {
                primary: '#2C3E50',
                secondary: '#7F8C8D',
              },
              success: '#4CAF50',
              error: '#F44336',
            },
            fontFamily: {
              inter: ['Inter', 'sans-serif'],
            },
            borderRadius: {
              chat: '18px',
            },
            boxShadow: {
              chat: '0 4px 12px rgba(156, 39, 176, 0.2)',
              bot: '0 4px 12px rgba(0,0,0,0.1)',
            },
          },
        },
      }
    </script>
    <style>
        :root {
            --primary-bg: #f5f3ff;
            --card-bg: rgba(255,255,255,0.7);
            --bubble-user: linear-gradient(90deg, #a78bfa 0%, #f0abfc 100%);
            --bubble-bot: #fff;
            --text-main: #312e81;
            --text-secondary: #7f8c8d;
            --accent: #a78bfa;
            --sidebar-bg: #232136;
            --sidebar-header-bg: #a78bfa;
            --input-bg: #fff;
            --input-border: #e5e7eb;
        }
        body.dark {
            --primary-bg: #18122b;
            --card-bg: rgba(34,34,51,0.7);
            --bubble-user: linear-gradient(90deg, #7c3aed 0%, #a78bfa 100%);
            --bubble-bot: #232136;
            --text-main: #e0e7ff;
            --text-secondary: #a1a1aa;
            --accent: #a78bfa;
            --sidebar-bg: #18122b;
            --sidebar-header-bg: #232136;
            --input-bg: #18122b; /* match primary-bg */
            --input-border: #3b3b4f;
        }
        body {
            background: var(--primary-bg);
            color: var(--text-main);
            transition: background 0.5s, color 0.5s;
        }
        .glass-card, .message-content {
            background: var(--card-bg);
            color: var(--text-main);
            transition: background 0.5s, color 0.5s;
        }
        .message.self-end .message-content {
            background: var(--bubble-user);
            color: #fff;
        }
        .message.self-start .message-content {
            background: var(--bubble-bot);
            color: var(--text-main);
        }
        .chat-input {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
        }
        #user-input {
            background: var(--input-bg);
            color: var(--text-main);
            border: 1px solid var(--input-border);
        }
        .message-timestamp, .session-date {
            color: var(--text-secondary) !important;
        }
        .message-status {
            color: var(--text-main);
        }
        .message-content {
            transition: background 0.5s;
        }
        .message.self-end {
            margin-left: auto;
            margin-right: 0;
            align-items: flex-end;
        }
        .message.self-start {
            margin-right: auto;
            margin-left: 0;
            align-items: flex-start;
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: -100%;
                top: 0;
                bottom: 0;
                width: 80%;
                max-width: 300px;
                z-index: 50;
                transition: left 0.3s ease;
                background: var(--primary-bg);
            }
            
            .sidebar.open {
                left: 0;
            }

            .main-panel {
                width: 100%;
                overflow-y: auto;
                scroll-behavior: smooth;
                padding-bottom: 80px; /* ensure space under keyboard */
            }

            .header-buttons button {
                font-size: 14px;
                padding: 6px 10px;
            }

            .message {
                max-width: 95% !important;
            }

            .chat-input {
                padding: 0.75rem;
            }

            #user-input {
                width: 100%;
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 0.75rem;
            }

            .header-buttons {
                gap: 0.5rem;
            }

            html, body {
                height: 100%;
                overscroll-behavior-y: contain;
            }

            #chat-messages {
                scroll-behavior: smooth;
            }
        }

        /* Sidebar transition */
        .sidebar-item {
            transition: background 0.3s, color 0.3s, transform 0.2s;
        }
        .sidebar-item.selected {
            background: linear-gradient(90deg, #a78bfa 0%, #f0abfc 100%);
            color: #fff;
            font-weight: 600;
            transform: scale(1.04);
            box-shadow: 0 2px 8px rgba(124,58,237,0.08);
        }
        .sidebar-item:not(.selected):hover {
            background: #ede9fe;
            color: #7c3aed;
            transform: scale(1.03);
        }

        /* Floating action button bounce */
        .floating-btn {
            animation: floatBounce 2.5s infinite ease-in-out;
        }
        @keyframes floatBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-8px) scale(1.08); }
        }
        /* Chat input bar focus animation */
        .chat-input:focus-within {
            box-shadow: 0 0 0 3px var(--accent);
            transition: box-shadow 0.3s;
        }
        /* Animated gradient background */
        .animated-bg {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 0;
            pointer-events: none;
            background: linear-gradient(120deg, #a78bfa 0%, #f0abfc 100%);
            opacity: 0.12;
            animation: gradientMove 12s ease-in-out infinite alternate;
        }
        @keyframes gradientMove {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        /* Floating shapes */
        .float-shape {
            position: absolute;
            border-radius: 50%;
            opacity: 0.18;
            pointer-events: none;
            animation: floatShape 16s linear infinite;
        }
        .float-shape1 { width: 120px; height: 120px; background: #a78bfa; top: 10%; left: 5%; animation-delay: 0s; }
        .float-shape2 { width: 80px; height: 80px; background: #f0abfc; top: 70%; left: 80%; animation-delay: 4s; }
        .float-shape3 { width: 60px; height: 60px; background: #7c3aed; top: 40%; left: 60%; animation-delay: 8s; }
        @keyframes floatShape {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-30px) scale(1.08); }
            100% { transform: translateY(0) scale(1); }
        }
        @media (max-width: 640px) {
            header .flex.items-center.gap-3 { gap: 0.5rem; }
            background-color: var(--primary-bg);
            .chat-input { flex-direction: column; gap: 0.5rem; padding: 1rem 0.5rem; }
            #user-input { width: 100%; }
            .chat-input-wrapper {padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.1); /* overrides pb-4 */}
        }
        .custom-header-bg {
            background: var(--sidebar-header-bg);
            color: var(--text-main);
            transition: background 0.5s, color 0.5s;
        }
        .custom-sidebar-bg {
            background: var(--sidebar-bg);
            color: var(--text-main);
            border-color: var(--input-border);
            transition: background 0.5s, color 0.5s, border-color 0.5s;
        }
        .custom-main-bg {
            background: var(--primary-bg);
            color: var(--text-main);
            transition: background 0.5s, color 0.5s;
        }
        body.dark .animated-bg {
            background: linear-gradient(120deg, #232136 0%, #7c3aed 100%);
            opacity: 0.18;
        }
        input#user-input,
        input#user-input:focus,
        input#user-input:-webkit-autofill {
            outline: none !important;
            border: none !important;
            box-shadow: none !important;
            -webkit-box-shadow: none !important;
            background-color: transparent !important;
            -webkit-text-fill-color: var(--text-main) !important;
        }
    </style>
</head>
<!-- <body class="bg-gradient-to-br from-primary-light to-white min-h-screen font-inter text-text-primary flex flex-col"> -->
<body class="bg-[var(--primary-bg)] min-h-screen font-inter text-text-primary flex flex-col">

    <div class="flex flex-col w-full h-screen">
        <!-- Header -->
        <header class="flex items-center justify-between px-4 py-3 custom-header-bg relative">
            <div class="flex items-center gap-2">
                <button id="menu-toggle" class="p-2 text-white md:hidden">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12h18M3 6h18M3 18h18"></path>
                    </svg>
                </button>
                <h1 class="text-xl md:text-2xl font-bold text-white tracking-tight">Lila - Your Personal Fragrance Stylist</h1>
            </div>
            <div class="flex items-center gap-2 header-buttons">
                <button id="theme-toggle" class="px-2 py-1 rounded-lg bg-white/70 text-purple-700 font-semibold shadow transition hover:bg-purple-100 z-40">🌙</button>
                <!-- <button class="bg-accent text-white px-3 py-1.5 md:px-4 md:py-2 rounded-lg font-medium shadow hover:bg-primary-dark transition new-chat-button" id="new-chat-btn">+ New Chat</button> -->
                <button class="bg-accent text-white px-3 sm:px-4 py-1.5 sm:py-2 rounded-lg font-medium shadow hover:bg-primary-dark transition whitespace-nowrap text-sm sm:text-base" id="new-chat-btn">
                    + New Chat
                </button>
                  
            </div>
        </header>
        <div class="flex flex-1 overflow-hidden relative">
            <!-- Sidebar -->
            <aside id="sidebar" class="sidebar w-64 custom-sidebar-bg flex flex-col border-r transition-all duration-300 z-10">
                <!-- <div class="sidebar-header bg-primary-dark px-4 py-3 font-bold text-lg">Lila</div> -->
                <div id="session-list" class="flex-1 overflow-y-auto mt-2 px-2"></div>
            </aside>
            <!-- Overlay for mobile -->
            <div id="sidebar-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden"></div>
            <!-- Main Panel -->
            <div class="main-panel flex flex-col flex-1 h-full custom-main-bg transition-all duration-300">
                <!-- Chat Messages -->
                <div id="chat-messages" class="flex-1 overflow-y-auto px-4 py-6 space-y-2"></div>
                <!-- Image Preview (dynamic) -->
                <div id="image-preview-container" class="image-preview-container"></div>
                <!-- Chat Input -->
                <div class="w-full px-4 pb-4 sticky bottom-0 z-20 chat-input-wrapper bg-transparent">
                    <div class="max-w-4xl mx-auto w-full flex items-center gap-2 bg-[var(--input-bg)] border border-[var(--input-border)] rounded-[25px] px-4 py-8 shadow transition-all">
                      <input
                        id="user-input"
                        type="text"
                        placeholder="Type your message here..."
                        autocomplete="on"
                        class="text-sm sm:text-base flex-1 appearance-none bg-transparent border-none outline-none ring-0 shadow-none text-base placeholder:text-[var(--text-secondary)] text-[var(--text-main)]"
                      />
                      <input type="file" id="image-upload" accept="image/*" multiple class="hidden" />
                      <button id="upload-btn" type="button" class="text-[var(--text-secondary)] hover:text-[var(--accent)]" title="Upload image">
                        <!-- Paperclip icon -->
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                          <path d="M21.44 11.05l-9.19 9.19a5 5 0 0 1-7.07-7.07l9.19-9.19a3 3 0 0 1 4.24 4.24l-9.2 9.19a1 1 0 0 1-1.41-1.41l9.2-9.19"/>
                        </svg>
                      </button>
                      <button id="send-btn" type="submit" class="bg-[var(--accent)] hover:bg-primary-dark text-white rounded-full p-2 shadow transition" title="Send message">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                          <line x1="22" y1="2" x2="11" y2="13"></line>
                          <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                      </button>
                    </div>
                  </div>
                  
  
  
                  
                
                <!-- Typing indicator -->
                <div id="typing-indicator" class="typing-indicator hidden"></div>
            </div>
        </div>
    </div>
    <!-- Only one set of animated backgrounds and floating action button before </body> -->
    <div class="animated-bg"></div>
    <div class="float-shape float-shape1"></div>
    <div class="float-shape float-shape2"></div>
    <div class="float-shape float-shape3"></div>
    <button class="floating-btn sm:hidden" title="New Chat">+</button>
    <script>
        let sessionId = null;
        let userId = localStorage.getItem('userId') || 'user_' + Math.random().toString(36).substr(2, 9);
        let isTyping = false;
        let typingTimeout;
        let currentStreamingMessage = null;
        let hasStartedSession = false;
        
        // Use environment-specific API URL
        const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:8000/api/v1'
            : 'https://fragrance-chatbot-v3.onrender.com/api/v1';
        
        const START_SESSION_URL = `${API_BASE_URL}/start-session`;
        const CHAT_URL = `${API_BASE_URL}/chat`;
        const START_SESSION_STREAM_URL = `${API_BASE_URL}/start-session-stream`;
        
        // Save user ID to localStorage
        localStorage.setItem('userId', userId);

        function formatMessage(message) {
            // Use marked to convert markdown to HTML
            return marked.parse(message);
        }

        function getTimestamp() {
            const now = new Date();
            return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        function createMessageElement(isUser) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';
            timestampDiv.textContent = getTimestamp();
            
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(timestampDiv);
            
            if (isUser) {
                const statusDiv = document.createElement('div');
                statusDiv.className = 'message-status';
                statusDiv.textContent = 'Sent';
                messageDiv.appendChild(statusDiv);
            }
            
            return { messageDiv, contentDiv };
        }
        
        function addMessage(message, isUser, showTimestamp = true, allowEmpty = false) {
            if ((!message || message.trim() === '') && !allowEmpty) {
                // Do not create a bubble for empty messages unless allowed (for streaming)
                return null;
            }
            const chatMessages = document.getElementById('chat-messages');
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `message flex flex-col max-w-[85%] ${isUser ? 'self-end items-end' : 'self-start items-start'} mb-2 fade-in-up`;
            const messageContent = document.createElement('div');
            messageContent.className = `glass-card prose max-w-none message-content px-5 py-3 rounded-chat shadow-chat text-base ${isUser ? 'bg-gradient-to-br from-primary to-accent text-white rounded-br-md' : 'bg-white text-text-primary rounded-bl-md border border-gray-200'} mb-1`;
            messageContent.innerHTML = formatMessage(message);
            messageWrapper.appendChild(messageContent);
            if (showTimestamp) {
                const timestamp = document.createElement('div');
                timestamp.className = 'message-timestamp text-xs text-text-secondary mt-1';
                const now = new Date();
                timestamp.textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                messageWrapper.appendChild(timestamp);
            }
            chatMessages.appendChild(messageWrapper);
            chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
            return messageContent;
        }

        function startStreamingResponse(isUser = false) {
            // Always allow an empty bubble for streaming
            return addMessage('', isUser, false, true);
        }

        function updateStreamingResponse(formattedText) {
            if (currentStreamingMessage) {
                    currentStreamingMessage.innerHTML = formattedText + '<span class="streaming-cursor">|</span>';
                const chatMessages = document.getElementById('chat-messages');
                chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
            }
        }

        function endStreamingResponse() {
            if (currentStreamingMessage) {
                // Remove the streaming cursor
                const cursor = currentStreamingMessage.querySelector('.streaming-cursor');
                if (cursor) cursor.remove();
                // Add timestamp after streaming is done
                const parent = currentStreamingMessage.parentElement;
                if (parent && !parent.querySelector('.message-timestamp')) {
                    const timestamp = document.createElement('div');
                    timestamp.className = 'message-timestamp text-xs text-text-secondary mt-1';
                    const now = new Date();
                    timestamp.textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    parent.appendChild(timestamp);
                }
                currentStreamingMessage = null;
            }
        }

        function showTypingIndicator() {
            document.getElementById('typing-indicator').classList.remove('hidden');
        }

        function hideTypingIndicator() {
            document.getElementById('typing-indicator').classList.add('hidden');
        }

        let lastTypingUpdate = 0;
        const TYPING_THROTTLE = 2000; // 2 seconds

        function updateTypingPreview() {
            const now = Date.now();
            if (now - lastTypingUpdate > TYPING_THROTTLE) {
                const input = document.getElementById('user-input');
                const preview = document.getElementById('typing-preview');
                
                if (input.value.trim() && !isTyping) {
                    // Show "User is typing..." to the bot
                    lastTypingUpdate = now;
                }
            }
        }

        async function startSessionStream() {
            const response = await fetch(START_SESSION_STREAM_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: userId })
            });
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let botMessage = '';
            let streamingStarted = false;
            let sessionIdSet = false;
            let leftover = '';
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const chunk = leftover + decoder.decode(value);
                const lines = chunk.split('\n');
                leftover = lines.pop(); // In case the last line is incomplete
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.startsWith('event: sessionId')) {
                        // Next line should be data: <session_id>
                        if (i + 1 < lines.length && lines[i + 1].startsWith('data: ')) {
                            sessionId = lines[i + 1].slice(6).trim();
                            sessionIdSet = true;
                            i++; // Skip the data line
                        }
                    } else if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        botMessage += data; // Accumulate streamed chunks
                        if (!streamingStarted) {
                            currentStreamingMessage = startStreamingResponse();
                            streamingStarted = true;
                        }
                        const safeHTML = DOMPurify.sanitize(marked.parse(botMessage));
                        updateStreamingResponse(safeHTML);
                    }
                }
            }
            endStreamingResponse();
            // Finalize the streaming message with full formatting
            if (currentStreamingMessage) {
                currentStreamingMessage.innerHTML = formatMessage(botMessage);
                currentStreamingMessage = null;
            }
            await loadSessionList(); // Refresh the left panel after streaming welcome message
        }

        async function initializeChat() {
            if (hasStartedSession) return;
            hasStartedSession = true;
            try {
                // Check if this is the first time user is visiting
                const isFirstVisit = !localStorage.getItem('hasVisited');
                await startSessionStream();  // Stream the welcome message
                // Mark that user has visited
                localStorage.setItem('hasVisited', 'true');
            } catch (error) {
                console.error('Error initializing chat:', error);
                addMessage('Sorry, I encountered an error. Please try again.', false);
            }
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function throttle(fn, delay) {
            let lastCall = 0;
            return (...args) => {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    fn(...args);
                }
            };
        }

        async function sendMessage() {
            const input = document.getElementById('user-input');
            const message = input.value.trim();
            
            // Prevent sending if sessionId is null
            if (!sessionId) {
                addMessage('Sorry, there was an error starting the session. Please refresh the page.', false);
                return;
            }
            
            if (message) {
                const messageId = generateUUID();
                // Show the user message immediately (optimistic UI)
                addMessage(message, true);

                input.value = '';
                showTypingIndicator();
                
                try {
                    console.log('Sending message to:', CHAT_URL);
                    console.log('Message data:', {
                        session_id: sessionId,
                        message: message,
                        message_id: messageId
                    });

                    // Use streaming for chat responses
                    const response = await fetch(CHAT_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            session_id: sessionId,
                            message: message,
                            message_id: messageId
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    if (!response.body) {
                        throw new Error('Response body is null');
                    }
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let rawMarkdown = '';
                    let streamingStarted = false;

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value);
                        console.log('Received chunk:', chunk); // Debug log
                        
                        const lines = chunk.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                rawMarkdown += data;

                                if (!streamingStarted) {
                                    currentStreamingMessage = startStreamingResponse();
                                    streamingStarted = true;
                                }

                                const html = DOMPurify.sanitize(marked.parse(rawMarkdown));
                                updateStreamingResponse(html);
                            }
                        }
                    }

                    // Final rendering after complete message is received
                    if (currentStreamingMessage) {
                        const finalHTML = DOMPurify.sanitize(marked.parse(rawMarkdown));
                        currentStreamingMessage.innerHTML = finalHTML;
                        endStreamingResponse();
                    }
                    
                    hideTypingIndicator();
                    await loadSessionList(); // Refresh the session list after new message
                    
                } catch (error) {
                    console.error('Error sending message:', error);
                    hideTypingIndicator();
                    addMessage('Sorry, there was an error sending your message. Please try again.', false);
                }
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        // Start chat when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            document.getElementById('user-input').focus();
            await loadSessionList(); // Load session list first!
            // Only initialize chat if there is no session selected
            if (!sessionId) {
                await initializeChat();
            } else {
                await loadChatHistory(sessionId);
            }
        });

        // Remove duplicate event listeners and consolidate them here
        function setupEventListeners() {
            // Send button
            const sendBtn = document.getElementById('send-btn');
            sendBtn.removeEventListener('click', sendMessage);
            sendBtn.addEventListener('click', sendMessage);

            // Enter key in chat input
            const userInput = document.getElementById('user-input');
            userInput.removeEventListener('keypress', handleKeyPress);
            userInput.addEventListener('keypress', handleKeyPress);

            // New Chat button
            const newChatBtn = document.getElementById('new-chat-btn');
            newChatBtn.removeEventListener('click', startNewConversation);
            newChatBtn.addEventListener('click', startNewConversation);

            // Upload button
            const uploadBtn = document.getElementById('upload-btn');
            uploadBtn.removeEventListener('click', () => document.getElementById('image-upload').click());
            uploadBtn.addEventListener('click', () => document.getElementById('image-upload').click());

            // Image upload
            const imageUpload = document.getElementById('image-upload');
            imageUpload.removeEventListener('change', handleImageUpload);
            imageUpload.addEventListener('change', handleImageUpload);

            // Theme toggle
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                themeToggle.removeEventListener('click', toggleTheme);
                themeToggle.addEventListener('click', toggleTheme);
                // Set correct icon on load
                themeToggle.textContent = document.body.classList.contains('dark') ? '☀️' : '🌙';
            }
        }

        function toggleTheme() {
            document.body.classList.toggle('dark');
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                themeToggle.textContent = document.body.classList.contains('dark') ? '☀️' : '🌙';
            }
        }

        async function startSession(isNewChat = false) {
            try {
                const response = await fetch(START_SESSION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        is_new_chat: isNewChat
                    })
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('Start session response:', data);
                sessionId = data.session_id;
                return data;
            } catch (error) {
                console.error('Error starting session:', error);
                return { message: 'Sorry, I encountered an error starting our conversation. Please try again.' };
            }
        }

        async function startNewConversation() {
            try {
                document.getElementById('chat-messages').innerHTML = '';
                sessionId = null;
                // Use the streaming endpoint and logic
                await startSessionStream();
                document.getElementById('user-input').focus();
                await loadSessionList();
            } catch (error) {
                console.error('Error starting new conversation:', error);
                addMessage('Sorry, there was an error starting a new conversation. Please try again.', false);
            }
        }

        async function handleImageUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            // Add user message about multiple images
            addMessage(`I've uploaded ${files.length} photo${files.length > 1 ? 's' : ''} of myself`, true);

            for (let i = 0; i < files.length; i++) {
                // Create a wrapper for preview + analysis
                const wrapper = document.createElement('div');
                wrapper.className = 'flex flex-col items-start mb-4';

                // Show preview
                const reader = new FileReader();
                const img = document.createElement('img');
                img.className = 'image-preview mb-2 rounded-lg shadow';
                img.alt = `Image ${i + 1}`;
                reader.onload = function(e) {
                    img.src = e.target.result;
                };
                reader.readAsDataURL(files[i]);
                wrapper.appendChild(img);

                // Show loading indicator
            const loadingBotMessage = document.createElement('div');
                loadingBotMessage.className = 'bot-message mt-2';
            loadingBotMessage.style.position = 'relative';
            loadingBotMessage.style.minHeight = '48px';
            loadingBotMessage.style.display = 'flex';
            loadingBotMessage.style.alignItems = 'center';
            loadingBotMessage.style.justifyContent = 'flex-start';
            loadingBotMessage.style.marginTop = '12px';
            loadingBotMessage.style.marginBottom = '12px';
            // Loading dots
            const loadingMessage = document.createElement('div');
            loadingMessage.className = 'dynamic-loading';
            const loadingTextSpan = document.createElement('span');
            loadingTextSpan.className = 'loading-fade';
            loadingTextSpan.style.marginLeft = '8px';
                loadingTextSpan.textContent = 'Analyzing your image...';
            loadingMessage.appendChild(loadingTextSpan);
            loadingBotMessage.appendChild(loadingMessage);
                wrapper.appendChild(loadingBotMessage);

                document.getElementById('chat-messages').appendChild(wrapper);

                // Convert image to base64
                const base64Image = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = error => reject(error);
                    reader.readAsDataURL(files[i]);
                });

                try {
                    // Send image to server and stream the response
                const response = await fetch(CHAT_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                            message: `Analyzing image ${i + 1} of ${files.length}`,
                        image_data: base64Image
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                    // Streaming logic for image analysis
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let accumulatedMarkdown = '';
                    let streamingStarted = false;
                    let streamingBubble = null;
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                accumulatedMarkdown += data;
                                if (!streamingStarted) {
                                    streamingBubble = startStreamingResponse();
                                    currentStreamingMessage = streamingBubble;
                                    streamingStarted = true;
                                }
                                // Real-time markdown rendering using marked and DOMPurify
                                const html = DOMPurify.sanitize(marked.parse(`**Analysis for image ${i + 1}:**\n${accumulatedMarkdown}`));
                                currentStreamingMessage.innerHTML = html + '<span class="streaming-cursor">|</span>';
                            }
                        }
                    }
                    
                    // After streaming, remove the cursor
                    if (currentStreamingMessage) {
                        const html = DOMPurify.sanitize(marked.parse(`**Analysis for image ${i + 1}:**\n${accumulatedMarkdown}`));
                        currentStreamingMessage.innerHTML = html;
                    }
                    endStreamingResponse();
            } catch (error) {
                    console.error('Error processing image:', error);
                    loadingBotMessage.replaceWith(document.createTextNode('Sorry, there was an error processing your image. Please try again.'));
                }
            }
        }

        function truncatePreview(text, maxLength = 40) {
            if (!text) return '';
            return text.length > maxLength ? text.slice(0, maxLength) + '...' : text;
        }

        async function loadSessionList() {
            const response = await fetch(`${API_BASE_URL}/sessions/${userId}`);
            const sessions = await response.json();
            const sessionListDiv = document.getElementById('session-list');
            sessionListDiv.innerHTML = '';
            sessions.forEach(session => {
                const isActive = session.session_id === sessionId;
                const div = document.createElement('div');
                div.className = 'session-item cursor-pointer flex flex-col px-4 py-3 mb-2 rounded-lg transition border border-transparent';
                if (isActive) {
                    div.classList.add('bg-primary', 'text-white', 'border-primary', 'shadow');
                div.innerHTML = `
                        <div class="session-preview font-semibold text-base truncate text-white">${truncatePreview(session.preview, 40) || 'No messages yet...'}</div>
                        <div class="session-date text-xs text-accent-light mt-1">${new Date(session.updated_at).toLocaleString()}</div>
                    `;
                } else {
                    div.classList.add('bg-background-light', 'text-text-primary', 'hover:bg-primary-light', 'hover:border-primary/30');
                    div.innerHTML = `
                        <div class="session-preview font-semibold text-base truncate text-text-primary">${truncatePreview(session.preview, 40) || 'No messages yet...'}</div>
                        <div class="session-date text-xs text-text-secondary mt-1">${new Date(session.updated_at).toLocaleString()}</div>
                    `;
                }
                div.onclick = () => selectSession(session.session_id);
                sessionListDiv.appendChild(div);
            });
        }

        async function selectSession(sid) {
            sessionId = sid;
            await loadChatHistory(sid);
            await loadSessionList();
        }

        async function loadChatHistory(sid) {
            const response = await fetch(`${API_BASE_URL}/history/${sid}`);
            const data = await response.json();
            document.getElementById('chat-messages').innerHTML = '';
            console.log('Loaded chat history:', data.messages); // Debug: log all messages
            data.messages.forEach(msg => {
                addMessage(msg.content, msg.role === 'user');
            });
        }

        // Move all initialization code into a single function
        async function initializeApp() {
            try {
                // Set up event listeners first
                setupEventListeners();
                
                // Focus the input
                document.getElementById('user-input').focus();
                
                // Load session list
                await loadSessionList();
                
                // Initialize chat if no session selected
                if (!sessionId) {
                    await initializeChat();
                } else {
                    await loadChatHistory(sessionId);
                }
            } catch (error) {
                console.error('Error initializing app:', error);
                addMessage('Sorry, there was an error initializing the chat. Please refresh the page.', false);
            }
        }

        // Call initializeApp when DOM is loaded
        document.addEventListener('DOMContentLoaded', initializeApp);

        function setupMobileSidebar() {
            const menuToggle = document.getElementById('menu-toggle');
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');

            function toggleSidebar() {
                sidebar.classList.toggle('open');
                overlay.classList.toggle('hidden');
                document.body.style.overflow = sidebar.classList.contains('open') ? 'hidden' : '';
            }

            menuToggle.addEventListener('click', toggleSidebar);
            overlay.addEventListener('click', toggleSidebar);

            // Close sidebar when clicking a session item on mobile
            document.getElementById('session-list').addEventListener('click', (e) => {
                if (e.target.closest('.sidebar-item') && window.innerWidth <= 768) {
                    toggleSidebar();
                }
            });
        }
    </script>
</body>
</html> 